// Generated by CoffeeScript 1.9.1
(function() {
  window.ModelValidator = (function() {
    var Bounds, Instance, JSONException, MetaModel, ValidationResult;

    MetaModel = window.MetaModel;

    Instance = window.Instance;

    ValidationResult = window.ValidationResult;

    JSONException = window.JSONException;

    Bounds = window.Bounds;

    function ModelValidator(metaModel) {
      if (metaModel != null) {
        this.setMetaModel(metaModel);
      }
    }

    ModelValidator.prototype.setMetaModel = function(metaModel) {
      var e, metaModelJSON;
      metaModelJSON = null;
      if (typeof metaModel === 'object') {
        metaModelJSON = metaModel;
      } else {
        try {
          metaModelJSON = JSON.parse(metaModel);
        } catch (_error) {
          e = _error;
          throw new JSONException("meta model", e.message);
        }
      }
      return this.metaModel = new MetaModel(metaModelJSON);
    };

    ModelValidator.prototype.validate = function(instance) {
      var e, i, instanceJSON, instanceKey, len, ref;
      if (this.metaModel == null) {
        throw "meta model is not initialized";
      }
      instanceJSON = null;
      if (typeof instance === 'object') {
        instanceJSON = instance;
      } else {
        try {
          instanceJSON = JSON.parse(instance);
        } catch (_error) {
          e = _error;
          throw new JSONException("instance", e.message);
        }
      }
      this.instance = new Instance(instanceJSON);
      this.result = new ValidationResult;
      this.globalUniqueAttributes = {};
      ref = this.instance.getKeys();
      for (i = 0, len = ref.length; i < len; i++) {
        instanceKey = ref[i];
        this.checkMObject(instanceKey);
      }
      return this.result;
    };

    ModelValidator.prototype.checkMObject = function(instanceKey) {
      if (this.instance.isClass(instanceKey)) {
        return this.checkMClass(instanceKey);
      } else if (this.instance.isReference(instanceKey)) {
        return this.checkMReference(instanceKey);
      } else {
        return this.result.addErrorMessage("'" + instanceKey + "' is neither mClass nor mReference.");
      }
    };

    ModelValidator.prototype.checkMClass = function(instanceKey) {
      var className;
      className = this.instance.getClassName(instanceKey);
      if (className == null) {
        this.result.addErrorMessage("Class '" + instanceKey + "' is broken.");
        return;
      }
      if (!this.metaModel.hasClass(className)) {
        this.result.addErrorMessage("Class '" + className + "' does not exist in meta model.");
        return;
      }
      this.checkInputs(instanceKey, className);
      this.checkOutputs(instanceKey, className);
      return this.checkAttributes(instanceKey);
    };

    ModelValidator.prototype.checkMReference = function(instanceKey) {
      var referenceName;
      referenceName = this.instance.getReferenceName(instanceKey);
      if (referenceName == null) {
        this.result.addErrorMessage("Reference '" + instanceKey + "' is broken.");
        return;
      }
      if (!this.metaModel.hasReference(referenceName)) {
        this.result.addErrorMessage("Reference '" + referenceName + "' does not exist in meta model.");
        return;
      }
      this.checkSources(instanceKey, referenceName);
      this.checkTargets(instanceKey, referenceName);
      return this.checkAttributes(instanceKey);
    };

    ModelValidator.prototype.checkInputs = function(instanceKey, className) {
      var bounds, inputs, referenceKey, values;
      inputs = this.instance.getInputs(instanceKey);
      if (inputs == null) {
        this.result.addErrorMessage("Class '" + instanceKey + "' does not have a 'inputs' field.");
        return;
      }
      for (referenceKey in inputs) {
        values = inputs[referenceKey];
        bounds = this.metaModel.getInputBounds(className, referenceKey);
        if (bounds == null) {
          this.result.addErrorMessage("Input reference '" + referenceKey + "' is not allowed for class '" + className + "'.");
          return;
        }
        switch (bounds.compareTo(values.length)) {
          case Bounds.TOO_LOW:
            this.result.addErrorMessage("Input count " + values.length + " of '" + instanceKey + "' for '" + referenceKey + "' is lower than lower bound " + (bounds.getLowerBound()) + " in '" + className + "'.");
            break;
          case Bounds.TOO_HIGH:
            this.result.addErrorMessage("Input count " + values.length + " of '" + instanceKey + "' for '" + referenceKey + "' is higher than upper bound " + (bounds.getUpperBound()) + " in '" + className + "'.");
        }
      }
    };

    ModelValidator.prototype.checkOutputs = function(instanceKey, className) {
      var bounds, outputs, referenceKey, values;
      outputs = this.instance.getOutputs(instanceKey);
      if (outputs == null) {
        this.result.addErrorMessage("Class '" + instanceKey + "' does not have a 'outputs' field.");
        return;
      }
      for (referenceKey in outputs) {
        values = outputs[referenceKey];
        bounds = this.metaModel.getOutputBounds(className, referenceKey);
        if (bounds == null) {
          this.result.addErrorMessage("Output reference '" + referenceKey + "' is not allowed for class '" + className + "'.");
          return;
        }
        switch (bounds.compareTo(values.length)) {
          case Bounds.TOO_LOW:
            this.result.addErrorMessage("Output count " + values.length + " of '" + instanceKey + "' for '" + referenceKey + "' is lower than lower bound " + (bounds.getLowerBound()) + " in '" + className + "'.");
            break;
          case Bounds.TOO_HIGH:
            this.result.addErrorMessage("Output count " + values.length + " of '" + instanceKey + "' for '" + referenceKey + "' is higher than upper bound " + (bounds.getUpperBound()) + " in '" + className + "'.");
        }
      }
    };

    ModelValidator.prototype.checkSources = function(instanceKey, referenceName) {
      var bounds, classKey, sources, values;
      sources = this.instance.getSources(instanceKey);
      if (sources == null) {
        this.result.addErrorMessage("Reference '" + instanceKey + "' does not have a 'source' field.");
        return;
      }
      for (classKey in sources) {
        values = sources[classKey];
        bounds = this.metaModel.getSourceBounds(referenceName, classKey);
        if (bounds == null) {
          this.result.addErrorMessage("Source class '" + classKey + "' is not allowed for reference '" + referenceName + "'.");
          return;
        }
        switch (bounds.compareTo(values.length)) {
          case Bounds.TOO_LOW:
            this.result.addErrorMessage("Source count " + values.length + " of '" + instanceKey + "' for '" + classKey + "' is lower than lower bound " + (bounds.getLowerBound()) + " in '" + referenceName + "'.");
            break;
          case Bounds.TOO_HIGH:
            this.result.addErrorMessage("Source count " + values.length + " of '" + instanceKey + "' for '" + classKey + "' is higher than upper bound " + (bounds.getUpperBound()) + " in '" + referenceName + "'.");
        }
      }
    };

    ModelValidator.prototype.checkTargets = function(instanceKey, referenceName) {
      var bounds, classKey, targets, values;
      targets = this.instance.getTargets(instanceKey);
      if (targets == null) {
        this.result.addErrorMessage("Reference '" + instanceKey + "' does not have a 'target' field.");
        return;
      }
      for (classKey in targets) {
        values = targets[classKey];
        bounds = this.metaModel.getTargetBounds(referenceName, classKey);
        if (bounds == null) {
          this.result.addErrorMessage("Target class '" + classKey + "' is not allowed for reference " + referenceName + ".");
          return;
        }
        switch (bounds.compareTo(values.length)) {
          case Bounds.TOO_LOW:
            this.result.addErrorMessage("Target count " + values.length + " of '" + instanceKey + "' for '" + classKey + "' is lower than lower bound '" + (bounds.getLowerBound()) + "' in '" + referenceName + "'.");
            break;
          case Bounds.TOO_HIGH:
            this.result.addErrorMessage("Target count " + values.length + " of '" + instanceKey + "' for '" + classKey + "' is higher than upper bound " + (bounds.getUpperBound()) + " in '" + referenceName + "'.");
        }
      }
    };

    ModelValidator.prototype.checkAttributes = function(instanceKey) {
      var attributeCount, attributeKey, attributeKeys, i, instanceAttributeValues, len, mObjName, metaAttribute, results;
      if (!this.instance.hasAttributes(instanceKey)) {
        return;
      }
      attributeKeys = this.instance.getAttributeKeys(instanceKey);
      if (attributeKeys == null) {
        return;
      }
      results = [];
      for (i = 0, len = attributeKeys.length; i < len; i++) {
        attributeKey = attributeKeys[i];
        mObjName = null;
        if (this.instance.isClass(instanceKey)) {
          mObjName = this.instance.getClassName(instanceKey);
        } else {
          mObjName = this.instance.getReferenceName(instanceKey);
        }
        if (mObjName == null) {
          this.result.addErrorMessage("'" + instanceKey + "' is broken.");
          continue;
        }
        metaAttribute = this.metaModel.getAttribute(mObjName, attributeKey);
        if (metaAttribute == null) {
          this.result.addErrorMessage("Attribute '" + attributeKey + "' does not exist in object '" + mObjName + "'.");
          continue;
        }
        instanceAttributeValues = this.instance.getAttribute(instanceKey, attributeKey);
        if (instanceAttributeValues == null) {
          this.result.addErrorMessage("'" + mObjName + "' '" + instanceKey + "' has no mAttributes with key '" + attributeKey + "'.");
          continue;
        }
        attributeCount = instanceAttributeValues.length;
        switch (metaAttribute.compareTo(attributeCount)) {
          case Bounds.TOO_LOW:
            this.result.addErrorMessage("'" + mObjName + "' '" + instanceKey + "' has " + attributeCount + " attributes of type '" + attributeKey + "', lower bound is " + (metaAttribute.getUpperBound()) + ".");
            break;
          case Bounds.TOO_HIGH:
            this.result.addErrorMessage("'" + mObjName + "' '" + instanceKey + "' has " + attributeCount + " attributes of type '" + attributeKey + "', upper bound is " + (metaAttribute.getLowerBound()) + ".");
        }
        if (metaAttribute.isUniqueGlobal()) {
          this.checkUniqueGlobalAttribute(attributeKey, instanceAttributeValues);
        }
        if (metaAttribute.isUniqueLocal()) {
          results.push(this.checkUniqueLocalAttribute(attributeKey, instanceAttributeValues));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    ModelValidator.prototype.checkUniqueGlobalAttribute = function(key, values) {
      var i, len, results, value;
      results = [];
      for (i = 0, len = values.length; i < len; i++) {
        value = values[i];
        if (this.globalUniqueAttributes[key] != null) {
          if (this.globalUniqueAttributes[key].indexOf(value) === -1) {
            results.push(this.globalUniqueAttributes[key].push(value));
          } else {
            results.push(this.result.addErrorMessage("Attribute '" + key + "' is not globally unique (duplicate value '" + value + "')."));
          }
        } else {
          results.push(this.globalUniqueAttributes[key] = [value]);
        }
      }
      return results;
    };

    ModelValidator.prototype.checkUniqueLocalAttribute = function(key, values) {
      var duplicateValues, i, len, results, value;
      duplicateValues = [];
      results = [];
      for (i = 0, len = values.length; i < len; i++) {
        value = values[i];
        if (values.indexOf(value) !== values.lastIndexOf(value) && duplicateValues.indexOf(value) === -1) {
          duplicateValues.push(value);
          results.push(this.result.addErrorMessage("Attribute '" + key + "' is not locally unique (duplicate value '" + value + "')."));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return ModelValidator;

  })();

}).call(this);

//# sourceMappingURL=ModelValidator.js.map
