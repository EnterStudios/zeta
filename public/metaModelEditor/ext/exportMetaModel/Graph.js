// Generated by CoffeeScript 1.9.1

/*
  Wrapper class around the internal JointJS graph.
  It provides methods for checking and extracting attributes from the graph.
 */

(function() {
  window.Graph = (function() {
    function Graph(graph) {
      this.graph = graph;
    }

    Graph.prototype.getElements = function() {
      return this.graph.getElements().filter(function(element) {
        return mCoreUtil.isElement(element);
      });
    };

    Graph.prototype.getElementNames = function() {
      return this.getElements().map(function(element) {
        return element.attributes.name;
      });
    };

    Graph.prototype.getReferences = function() {
      return this.graph.getLinks().filter(function(link) {
        return mCoreUtil.isReference(link);
      });
    };

    Graph.prototype.getReferenceNames = function() {
      return this.getReferences().map(function(reference) {
        return reference.attributes.name;
      });
    };

    Graph.prototype.getName = function(cell) {
      return cell.attributes.name;
    };

    Graph.prototype.getDuplicateKeys = function() {
      var duplicateKeys, i, key, keys, len, ref;
      keys = [];
      duplicateKeys = [];
      ref = this.getElementNames().concat(this.getReferenceNames()).concat(mEnum.getMEnumNames());
      for (i = 0, len = ref.length; i < len; i++) {
        key = ref[i];
        if (keys.indexOf(key) === -1) {
          keys.push(key);
        } else {
          duplicateKeys.push(key);
        }
      }
      return duplicateKeys;
    };

    Graph.prototype.getDuplicateAttributes = function() {
      var attribute, attributes, cell, duplicateAttributes, i, j, key, len, len1, ref, ref1;
      duplicateAttributes = [];
      ref = this.getElements().concat(this.getReferences());
      for (i = 0, len = ref.length; i < len; i++) {
        cell = ref[i];
        if (cell.attributes[Constants.field.ATTRIBUTES] != null) {
          attributes = [];
          ref1 = cell.attributes[Constants.field.ATTRIBUTES];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            attribute = ref1[j];
            key = attribute.name;
            if (attributes.indexOf(key) === -1) {
              attributes.push(key);
            } else {
              duplicateAttributes.push(new Attribute(cell.attributes.name, key));
            }
          }
        }
      }
      return duplicateAttributes;
    };

    Graph.prototype.isAbstract = function(element) {
      return mCoreUtil.isAbstract(element);
    };

    Graph.prototype.getSuperTypes = function(element) {
      return this.graph.getConnectedLinks(element, {
        outbound: true
      }).filter(function(link) {
        return mCoreUtil.isGeneralization(link);
      }).map((function(link) {
        return this.graph.getCell(link.attributes.target.id).attributes.name;
      }), this);
    };

    Graph.prototype.getAttributes = function(cell) {
      var attributes, i, key, len, mAttributes, ref, value;
      mAttributes = {};
      if (cell.attributes[Constants.field.ATTRIBUTES] != null) {
        ref = cell.attributes[Constants.field.ATTRIBUTES];
        for (i = 0, len = ref.length; i < len; i++) {
          attributes = ref[i];
          mAttributes[attributes.name] = {};
          for (key in attributes) {
            value = attributes[key];
            mAttributes[attributes.name][key] = value;
          }
        }
      }
      return mAttributes;
    };

    Graph.prototype.getInputs = function(element) {
      var inputs;
      inputs = this.graph.getConnectedLinks(element, {
        inbound: true
      }).filter(function(link) {
        return mCoreUtil.isReference(link);
      });
      return this.createLinkdef(element, inputs, Constants.field.LINKDEF_INPUT);
    };

    Graph.prototype.getOutputs = function(element) {
      var outputs;
      outputs = this.graph.getConnectedLinks(element, {
        outbound: true
      }).filter(function(link) {
        return mCoreUtil.isReference(link);
      });
      return this.createLinkdef(element, outputs, Constants.field.LINKDEF_OUTPUT);
    };

    Graph.prototype.getSources = function(reference) {
      var sources;
      sources = [this.graph.getCell(reference.attributes.source.id)];
      return this.createLinkdef(reference, sources, Constants.field.LINKDEF_SOURCE);
    };

    Graph.prototype.getTargets = function(reference) {
      var targets;
      targets = [this.graph.getCell(reference.attributes.target.id)];
      return this.createLinkdef(reference, targets, Constants.field.LINKDEF_TARGET);
    };

    Graph.prototype.getSourceDeletionDeletesTarget = function(reference) {
      return reference.attributes[Constants.field.SOURCE_DELETION_DELETES_TARGET] || false;
    };

    Graph.prototype.getTargetDeletionDeletesSource = function(reference) {
      return reference.attributes[Constants.field.TARGET_DELETION_DELETES_SOURCE] || false;
    };


    /*
      Creates the linkdef object for the element.
      connectedCells is an array of the directly connected cells (if element is a class, connectedCells is a list
      of references, if element is a reference, connectedCells is a list of classes).
      FieldName is inputs, outputs, source or target.
     */

    Graph.prototype.createLinkdef = function(element, connectedCells, fieldName) {
      var cell, i, len, linkdef, match, obj;
      linkdef = [];
      for (i = 0, len = connectedCells.length; i < len; i++) {
        cell = connectedCells[i];
        obj = {
          type: cell.attributes.name,
          upperBound: 1,
          lowerBound: 1,
          deleteIfLower: false
        };
        if ((element.attributes != null) && (element.attributes[fieldName] != null)) {
          match = element.attributes[fieldName].filter(function(field) {
            return field.type === obj.type;
          });
          if (match.length > 0) {
            obj = {
              type: obj.type,
              upperBound: match[0].upperBound,
              lowerBound: match[0].lowerBound,
              deleteIfLower: match[0].deleteIfLower
            };
          }
        }
        linkdef.push(obj);
      }
      return linkdef;
    };

    return Graph;

  })();

}).call(this);

//# sourceMappingURL=Graph.js.map
