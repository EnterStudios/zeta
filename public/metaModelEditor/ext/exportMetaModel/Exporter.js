// Generated by CoffeeScript 1.9.1
(function() {
  window.Exporter = (function() {

    /*
      Constructor function.
      graph: the internal representation of the JointJS graph.
     */
    function Exporter(graph) {
      this.graph = new Graph(graph);
    }


    /*
      Exports the graph.
      This is the only public method of this class!
      returns an instance of the ExportedMetaModel class which contains the exported JSON graph and error messages.
     */

    Exporter.prototype["export"] = function() {
      var exportedModel, validationResult;
      exportedModel = new ExportedMetaModel;
      validationResult = this.checkValidity();
      exportedModel.setValid(validationResult.isValid());
      exportedModel.setMessages(validationResult.getMessages());
      if (validationResult.isValid()) {
        exportedModel.setMetaModel(this.createMetaModel());
      }
      return exportedModel;
    };


    /*
      Checks, if the graph is in a state that allows exporting it.
      returns an instance of the ValidationResult class.
     */

    Exporter.prototype.checkValidity = function() {
      var attribute, i, j, key, len, len1, ref, ref1, validationResult;
      validationResult = new ValidationResult;
      ref = this.graph.getDuplicateKeys();
      for (i = 0, len = ref.length; i < len; i++) {
        key = ref[i];
        validationResult.addErrorMessage("Duplicate key '" + key + "'");
      }
      ref1 = this.graph.getDuplicateAttributes();
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        attribute = ref1[j];
        validationResult.addErrorMessage("Duplicate attribute '" + (attribute.getAttributeKey()) + "' in cell '" + (attribute.getCellName()) + "'");
      }
      return validationResult;
    };

    Exporter.prototype.createMetaModel = function() {
      var metaModel;
      metaModel = {};
      this.addClasses(metaModel);
      this.addReferences(metaModel);
      this.addEnums(metaModel);
      return metaModel;
    };

    Exporter.prototype.addClasses = function(metaModel) {
      var element, i, len, ref, results;
      ref = this.graph.getElements();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        element = ref[i];
        results.push(metaModel[this.graph.getName(element)] = {
          mType: Constants.CLASS,
          name: this.graph.getName(element),
          abstract: this.graph.isAbstract(element),
          superTypes: this.graph.getSuperTypes(element),
          mAttributes: this.graph.getAttributes(element),
          inputs: this.graph.getInputs(element),
          outputs: this.graph.getOutputs(element)
        });
      }
      return results;
    };

    Exporter.prototype.addReferences = function(metaModel) {
      var i, len, ref, reference, results;
      ref = this.graph.getReferences();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        reference = ref[i];
        results.push(metaModel[this.graph.getName(reference)] = {
          mType: Constants.REFERENCE,
          name: this.graph.getName(reference),
          sourceDeletionDeletesTarget: this.graph.getSourceDeletionDeletesTarget(reference),
          targetDeletionDeletesSource: this.graph.getTargetDeletionDeletesSource(reference),
          mAttributes: this.graph.getAttributes(reference),
          source: this.graph.getSources(reference),
          target: this.graph.getTargets(reference)
        });
      }
      return results;
    };

    Exporter.prototype.addEnums = function(metaModel) {
      var i, len, ref, results, thisMEnum;
      ref = mEnum.getMEnums();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        thisMEnum = ref[i];
        results.push(metaModel[thisMEnum.name] = {
          mType: Constants.ENUM,
          name: thisMEnum.name,
          type: thisMEnum.type,
          values: mEnum.getValues(thisMEnum.name)
        });
      }
      return results;
    };

    return Exporter;

  })();

}).call(this);

//# sourceMappingURL=Exporter.js.map
